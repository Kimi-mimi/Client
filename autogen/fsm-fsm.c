/*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (fsm-fsm.c)
 *
 *  It has been AutoGen-ed
 *  From the definitions    fsm.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2018 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#define DEFINE_FSM
#include "fsm-fsm.h"
#include <stdio.h>

/*
 *  Do not make changes to this file, except between the START/END
 *  comments, or it will be removed the next time it is generated.
 */
/* START === USER HEADERS === DO NOT CHANGE THIS COMMENT */
#include <sys/select.h>
#include "../smtp/smtp_connection_list.h"
#include "../smtp/smtp_connection.h"
#include "../smtp/smtp_command.h"
#include "../bytes/string.h"
#include "../logger/logger.h"
#include "../errors/client_errors.h"
#include "fsm-common.h"
/* END   === USER HEADERS === DO NOT CHANGE THIS COMMENT */

#ifndef NULL
#  define NULL 0
#endif

/**
 *  Callback routine prototype.  They return the next state.  Normally, that
 *  should be the value of the "maybe_next" argument.
 */
typedef te_fsm_state (fsm_callback_t)(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt );

static fsm_callback_t
    fsm_do_closed_by_remote,
    fsm_do_connect_bad,
    fsm_do_connect_success,
    fsm_do_connect_unreadable,
    fsm_do_data_bad,
    fsm_do_data_success,
    fsm_do_data_unreadable,
    fsm_do_decided_to_data,
    fsm_do_decided_to_mail_from,
    fsm_do_decided_to_quit,
    fsm_do_decided_to_rcpt,
    fsm_do_helo_bad,
    fsm_do_helo_success_decide_mail_from_or_quit,
    fsm_do_helo_unreadable,
    fsm_do_internal_error_decide_to_reconnect_or_close,
    fsm_do_invalid,
    fsm_do_log_decided_to_close,
    fsm_do_log_decided_to_reconnect,
    fsm_do_mail_from_bad_decide_mail_from_or_quit,
    fsm_do_mail_from_success_decide_rcpt_to_or_data,
    fsm_do_mail_from_unreadable_decide_mail_from_or_quit,
    fsm_do_message_bad_decide_to_mail_from_or_quit,
    fsm_do_message_success_decide_to_mail_from_or_quit,
    fsm_do_message_unreadable_decide_to_mail_from_or_quit,
    fsm_do_quit_bad,
    fsm_do_quit_success,
    fsm_do_quit_unreadable,
    fsm_do_rcpt_to_bad_decide_rcpt_to_or_data,
    fsm_do_rcpt_to_success_decide_rcpt_to_or_data,
    fsm_do_rcpt_to_unreadable,
    fsm_do_rset_bad_decide_to_reconnect_or_close,
    fsm_do_rset_success_decide_to_mail_to_or_quit,
    fsm_do_rset_unreadable_decide_to_reconnect_or_close,
    fsm_do_send_bytes;

/**
 *  Declare all the state transition handling routines.
 */
typedef struct transition t_fsm_transition;
struct transition {
    te_fsm_state      next_state;
    fsm_callback_t *  trans_proc;
};

/**
 *  State transition maps.  Map the enumeration and the event enumeration
 *  to the new state and the transition enumeration code (in that order).
 *  It is indexed by first the current state and then the event code.
 */
static const t_fsm_transition
fsm_trans_table[ FSM_STATE_CT ][ FSM_EVENT_CT ] = {

  /* STATE 0:  FSM_ST_INIT */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  GOOD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 1:  FSM_ST_CLOSING */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  GOOD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 2:  FSM_ST_CLOSED */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  GOOD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 3:  FSM_ST_CONNECTING */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_SENDING_HELO, fsm_do_connect_success }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_CLOSED, fsm_do_connect_bad },          /* EVT:  BAD_RESPONSE */
    { FSM_ST_CLOSED, fsm_do_connect_unreadable },   /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 4:  FSM_ST_SENDING_HELO */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_HELO, fsm_do_send_bytes },     /* EVT:  SEND_BYTES */
    { FSM_ST_NEED_TO_MAIL_FROM_OR_QUIT, fsm_do_helo_success_decide_mail_from_or_quit }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_CLOSED, fsm_do_helo_bad },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_CLOSED, fsm_do_helo_unreadable },      /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 5:  FSM_ST_SENDING_MAIL_FROM */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_MAIL_FROM, fsm_do_send_bytes }, /* EVT:  SEND_BYTES */
    { FSM_ST_NEED_TO_RCPT_TO_OR_DATA, fsm_do_mail_from_success_decide_rcpt_to_or_data }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_NEED_TO_MAIL_FROM_OR_QUIT, fsm_do_mail_from_bad_decide_mail_from_or_quit }, /* EVT:  BAD_RESPONSE */
    { FSM_ST_NEED_TO_MAIL_FROM_OR_QUIT, fsm_do_mail_from_unreadable_decide_mail_from_or_quit }, /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 6:  FSM_ST_SENDING_RCPT_TO */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_RCPT_TO, fsm_do_send_bytes },  /* EVT:  SEND_BYTES */
    { FSM_ST_NEED_TO_RCPT_TO_OR_DATA, fsm_do_rcpt_to_success_decide_rcpt_to_or_data }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_NEED_TO_RCPT_TO_OR_DATA, fsm_do_rcpt_to_bad_decide_rcpt_to_or_data }, /* EVT:  BAD_RESPONSE */
    { FSM_ST_SENDING_RSET, fsm_do_rcpt_to_unreadable }, /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 7:  FSM_ST_SENDING_DATA */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_DATA, fsm_do_send_bytes },     /* EVT:  SEND_BYTES */
    { FSM_ST_SENDING_MESSAGE, fsm_do_data_success }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_SENDING_RSET, fsm_do_data_bad },       /* EVT:  BAD_RESPONSE */
    { FSM_ST_SENDING_RSET, fsm_do_data_unreadable }, /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 8:  FSM_ST_SENDING_MESSAGE */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_MESSAGE, fsm_do_send_bytes },  /* EVT:  SEND_BYTES */
    { FSM_ST_NEED_TO_MAIL_FROM_OR_QUIT, fsm_do_message_success_decide_to_mail_from_or_quit }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_SENDING_RSET, fsm_do_message_bad_decide_to_mail_from_or_quit }, /* EVT:  BAD_RESPONSE */
    { FSM_ST_SENDING_RSET, fsm_do_message_unreadable_decide_to_mail_from_or_quit }, /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 9:  FSM_ST_SENDING_RSET */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_RSET, fsm_do_send_bytes },     /* EVT:  SEND_BYTES */
    { FSM_ST_NEED_TO_MAIL_FROM_OR_QUIT, fsm_do_rset_success_decide_to_mail_to_or_quit }, /* EVT:  GOOD_RESPONSE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_rset_bad_decide_to_reconnect_or_close }, /* EVT:  BAD_RESPONSE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_rset_unreadable_decide_to_reconnect_or_close }, /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 10:  FSM_ST_SENDING_QUIT */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_SENDING_QUIT, fsm_do_send_bytes },     /* EVT:  SEND_BYTES */
    { FSM_ST_CLOSED, fsm_do_quit_success },         /* EVT:  GOOD_RESPONSE */
    { FSM_ST_CLOSED, fsm_do_quit_bad },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_CLOSED, fsm_do_quit_unreadable },      /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 11:  FSM_ST_NEED_TO_RCPT_TO_OR_DATA */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  GOOD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_SENDING_RCPT_TO, fsm_do_decided_to_rcpt }, /* EVT:  NEED_RCPT_TO */
    { FSM_ST_SENDING_DATA, fsm_do_decided_to_data }, /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 12:  FSM_ST_NEED_TO_MAIL_FROM_OR_QUIT */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  GOOD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_SENDING_MAIL_FROM, fsm_do_decided_to_mail_from }, /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_SENDING_QUIT, fsm_do_decided_to_quit }, /* EVT:  NEED_QUIT */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RECONNECT */
    { FSM_ST_INVALID, fsm_do_invalid }              /* EVT:  NEED_CLOSE */
  },

  /* STATE 13:  FSM_ST_NEED_TO_RECONNECT_OR_CLOSE */
  { { FSM_ST_CLOSING, fsm_do_closed_by_remote },    /* EVT:  CONNECTION_CLOSED_BY_REMOTE */
    { FSM_ST_NEED_TO_RECONNECT_OR_CLOSE, fsm_do_internal_error_decide_to_reconnect_or_close }, /* EVT:  INTERNAL_ERROR */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  SEND_BYTES */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  GOOD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  BAD_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  UNREADABLE_RESPONSE */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_RCPT_TO */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_DATA */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_MAIL_FROM */
    { FSM_ST_INVALID, fsm_do_invalid },             /* EVT:  NEED_QUIT */
    { FSM_ST_CONNECTING, fsm_do_log_decided_to_reconnect }, /* EVT:  NEED_RECONNECT */
    { FSM_ST_CLOSED, fsm_do_log_decided_to_close }  /* EVT:  NEED_CLOSE */
  }
};


#define FsmFsmErr_off     19
#define FsmEvInvalid_off  75
#define FsmStInit_off     83


static char const zFsmStrings[468] =
/*     0 */ "** OUT-OF-RANGE **\0"
/*    19 */ "FSM Error:  in state %d (%s), event %d (%s) is invalid\n\0"
/*    75 */ "invalid\0"
/*    83 */ "init\0"
/*    88 */ "closing\0"
/*    96 */ "closed\0"
/*   103 */ "connecting\0"
/*   114 */ "sending_helo\0"
/*   127 */ "sending_mail_from\0"
/*   145 */ "sending_rcpt_to\0"
/*   161 */ "sending_data\0"
/*   174 */ "sending_message\0"
/*   190 */ "sending_rset\0"
/*   203 */ "sending_quit\0"
/*   216 */ "need_to_rcpt_to_or_data\0"
/*   240 */ "need_to_mail_from_or_quit\0"
/*   266 */ "need_to_reconnect_or_close\0"
/*   293 */ "connection_closed_by_remote\0"
/*   321 */ "internal_error\0"
/*   336 */ "send_bytes\0"
/*   347 */ "good_response\0"
/*   361 */ "bad_response\0"
/*   374 */ "unreadable_response\0"
/*   394 */ "need_rcpt_to\0"
/*   407 */ "need_data\0"
/*   417 */ "need_mail_from\0"
/*   432 */ "need_quit\0"
/*   442 */ "need_reconnect\0"
/*   457 */ "need_close";

static const size_t aszFsmStates[14] = {
    83,  88,  96,  103, 114, 127, 145, 161, 174, 190, 203, 216, 240, 266 };

static const size_t aszFsmEvents[13] = {
    293, 321, 336, 347, 361, 374, 394, 407, 417, 432, 442, 457, 75 };


#define FSM_EVT_NAME(t)   ( (((unsigned)(t)) >= 13) \
    ? zFsmStrings : zFsmStrings + aszFsmEvents[t])

#define FSM_STATE_NAME(s) ( (((unsigned)(s)) >= 14) \
    ? zFsmStrings : zFsmStrings + aszFsmStates[s])

#ifndef EXIT_FAILURE
# define EXIT_FAILURE 1
#endif

static int fsm_invalid_transition( te_fsm_state st, te_fsm_event evt );

/* * * * * * * * * THE CODE STARTS HERE * * * * * * * */
/**
 *  Print out an invalid transition message and return EXIT_FAILURE
 */
static int
fsm_invalid_transition( te_fsm_state st, te_fsm_event evt )
{
    /* START == INVALID TRANS MSG == DO NOT CHANGE THIS COMMENT */
    char const * fmt = zFsmStrings + FsmFsmErr_off;
    fprintf( stderr, fmt, st, FSM_STATE_NAME(st), evt, FSM_EVT_NAME(evt));
    /* END   == INVALID TRANS MSG == DO NOT CHANGE THIS COMMENT */

    return EXIT_FAILURE;
}

static te_fsm_state
fsm_do_closed_by_remote(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == CLOSED BY REMOTE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logClosedByRemote(smtpConnection->socket,
                      smtpConnection->domain);
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == CLOSED BY REMOTE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_connect_bad(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == CONNECT BAD == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "connect");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == CONNECT BAD == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_connect_success(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == CONNECT SUCCESS == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "connect");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next,  FSM_STATE_NAME(maybe_next));
    String *heloCommand = getHELOCommand();
    if (!heloCommand || stringConcat(smtpConnection->writeBuffer, heloCommand) < 0) {
        stringDeinit(heloCommand);
        return fsm_step(smtpConnection->connState, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    stringDeinit(heloCommand);
    FD_SET(smtpConnection->socket, writeFdSet);
    return maybe_next;
/*  END   == CONNECT SUCCESS == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_connect_unreadable(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == CONNECT UNREADABLE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logUnreadableResponse(smtpConnection->socket,
                          smtpConnection->domain,
                          response,
                          "connect");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == CONNECT UNREADABLE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_data_bad(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DATA BAD == DO NOT CHANGE THIS COMMENT  */
    return responseBadAndNeedRset(connection, head, response, readFdSet, writeFdSet, "DATA",
                                  FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == DATA BAD == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_data_success(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DATA SUCCESS == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "DATA");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    String *message = stringInitCopy(smtpConnection->currentMessage->data);
    if (!message || stringConcat(smtpConnection->writeBuffer, message) < 0) {
        stringDeinit(message);
        return fsm_step(smtpConnection->connState, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    stringDeinit(message);
    FD_SET(smtpConnection->socket, writeFdSet);
    return maybe_next;
/*  END   == DATA SUCCESS == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_data_unreadable(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DATA UNREADABLE == DO NOT CHANGE THIS COMMENT  */
    return responseUnreadableAndNeedRset(connection, head, response, readFdSet, writeFdSet, "DATA",
                                         FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == DATA UNREADABLE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_decided_to_data(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DECIDED TO DATA == DO NOT CHANGE THIS COMMENT  */
    String *dataCommand = getDATACommand();
    if (!dataCommand) {
        stringDeinit(dataCommand);
        return fsm_step(initial, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    return decidedTo(maybe_next, connection, head, response, readFdSet, writeFdSet, dataCommand,
                     FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == DECIDED TO DATA == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_decided_to_mail_from(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DECIDED TO MAIL FROM == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    smtpConnectionClearCurrentMessage(smtpConnection);
    if (smtpConnectionSetCurrentMessage(smtpConnection) < 0) {
        return fsm_step(smtpConnection->connState, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    String *mailCommand = getMAILFROMCommand(smtpConnection->currentMessage->from);
    if (!mailCommand) {
        stringDeinit(mailCommand);
        return fsm_step(smtpConnection->connState, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    return decidedTo(maybe_next, connection, head, response, readFdSet, writeFdSet, mailCommand,
                     FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == DECIDED TO MAIL FROM == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_decided_to_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DECIDED TO QUIT == DO NOT CHANGE THIS COMMENT  */
    String *quitCommand = getQUITCommand();
    if (!quitCommand) {
        stringDeinit(quitCommand);
        return fsm_step(initial, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    return decidedTo(maybe_next, connection, head, response, readFdSet, writeFdSet, quitCommand,
                     FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == DECIDED TO QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_decided_to_rcpt(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == DECIDED TO RCPT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    String *rcptCommand = getRCPTTOCommand(smtpConnection->currentMessage->recipients[smtpConnection->sentRcptTos++]);
    if (!rcptCommand) {
        stringDeinit(rcptCommand);
        return fsm_step(smtpConnection->connState, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    return decidedTo(maybe_next, connection, head, response, readFdSet, writeFdSet, rcptCommand,
                     FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == DECIDED TO RCPT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_helo_bad(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == HELO BAD == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "HELO");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == HELO BAD == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_helo_success_decide_mail_from_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == HELO SUCCESS DECIDE MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "HELO");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(smtpConnection, head, response, readFdSet, writeFdSet);
/*  END   == HELO SUCCESS DECIDE MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_helo_unreadable(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == HELO UNREADABLE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logUnreadableResponse(smtpConnection->socket,
                          smtpConnection->domain,
                          response,
                          "connect");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == HELO UNREADABLE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_internal_error_decide_to_reconnect_or_close(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == INTERNAL ERROR DECIDE TO RECONNECT OR CLOSE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logInternalError(smtpConnection->socket,
                     smtpConnection->domain);
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideReconnectOrClose(smtpConnection, head, response, readFdSet, writeFdSet);
/*  END   == INTERNAL ERROR DECIDE TO RECONNECT OR CLOSE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_invalid(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == INVALID == DO NOT CHANGE THIS COMMENT  */
    fsm_invalid_transition(initial, trans_evt);
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logInvalidTransition(
            smtpConnection->socket,
            smtpConnection->domain);
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == INVALID == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_log_decided_to_close(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == LOG DECIDED TO CLOSE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logDecidedTo(smtpConnection->socket,
                 smtpConnection->domain,
                 "close");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == LOG DECIDED TO CLOSE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_log_decided_to_reconnect(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == LOG DECIDED TO RECONNECT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logDecidedTo(smtpConnection->socket,
                 smtpConnection->domain,
                 "reconnect");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    FD_CLR(smtpConnection->socket, writeFdSet);
    if (smtpConnectionReconnect(smtpConnection, 1) < 0) {
        return fsm_step(smtpConnection->connState, FSM_EV_INTERNAL_ERROR, head, connection, response, readFdSet, writeFdSet);
    }
    return maybe_next;
/*  END   == LOG DECIDED TO RECONNECT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_mail_from_bad_decide_mail_from_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == MAIL FROM BAD DECIDE MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection* smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "MAIL FROM");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(smtpConnection, head, response, readFdSet, writeFdSet);
/*  END   == MAIL FROM BAD DECIDE MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_mail_from_success_decide_rcpt_to_or_data(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == MAIL FROM SUCCESS DECIDE RCPT TO OR DATA == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "MAIL FROM");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideRcptOrData(connection, head, response, readFdSet, writeFdSet);
/*  END   == MAIL FROM SUCCESS DECIDE RCPT TO OR DATA == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_mail_from_unreadable_decide_mail_from_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == MAIL FROM UNREADABLE DECIDE MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logUnreadableResponse(smtpConnection->socket,
                          smtpConnection->domain,
                          response,
                          "MAIL FROM");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(connection, head, response, readFdSet, writeFdSet);
/*  END   == MAIL FROM UNREADABLE DECIDE MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_message_bad_decide_to_mail_from_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == MESSAGE BAD DECIDE TO MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "message");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(connection, head, response, readFdSet, writeFdSet);
/*  END   == MESSAGE BAD DECIDE TO MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_message_success_decide_to_mail_from_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == MESSAGE SUCCESS DECIDE TO MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection* smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "message");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(smtpConnection, head, response, readFdSet, writeFdSet);
/*  END   == MESSAGE SUCCESS DECIDE TO MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_message_unreadable_decide_to_mail_from_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == MESSAGE UNREADABLE DECIDE TO MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logUnreadableResponse(smtpConnection->socket,
                          smtpConnection->domain,
                          response,
                          "message");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(connection, head, response, readFdSet, writeFdSet);
/*  END   == MESSAGE UNREADABLE DECIDE TO MAIL FROM OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_quit_bad(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == QUIT BAD == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "QUIT");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == QUIT BAD == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_quit_success(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == QUIT SUCCESS == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "QUIT");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == QUIT SUCCESS == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_quit_unreadable(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == QUIT UNREADABLE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logUnreadableResponse(smtpConnection->socket,
                          smtpConnection->domain,
                          response,
                          "QUIT");
    return closeConnection(connection, head, response, readFdSet, writeFdSet,
                           FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == QUIT UNREADABLE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_rcpt_to_bad_decide_rcpt_to_or_data(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == RCPT TO BAD DECIDE RCPT TO OR DATA == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "RCPT TO");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideRcptOrData(smtpConnection, head, response, readFdSet, writeFdSet);
/*  END   == RCPT TO BAD DECIDE RCPT TO OR DATA == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_rcpt_to_success_decide_rcpt_to_or_data(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == RCPT TO SUCCESS DECIDE RCPT TO OR DATA == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "RCPT TO");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideRcptOrData(smtpConnection, head, response, readFdSet, writeFdSet);
/*  END   == RCPT TO SUCCESS DECIDE RCPT TO OR DATA == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_rcpt_to_unreadable(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == RCPT TO UNREADABLE == DO NOT CHANGE THIS COMMENT  */
    return responseUnreadableAndNeedRset(connection, head, response, readFdSet, writeFdSet, "RCPT TO",
                                         FSM_STATE_NAME(initial), FSM_STATE_NAME(maybe_next));
/*  END   == RCPT TO UNREADABLE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_rset_bad_decide_to_reconnect_or_close(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == RSET BAD DECIDE TO RECONNECT OR CLOSE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logBadResponse(smtpConnection->socket,
                   smtpConnection->domain,
                   response,
                   "RSET");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideReconnectOrClose(connection, head, response, readFdSet, writeFdSet);
/*  END   == RSET BAD DECIDE TO RECONNECT OR CLOSE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_rset_success_decide_to_mail_to_or_quit(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == RSET SUCCESS DECIDE TO MAIL TO OR QUIT == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logGoodResponse(smtpConnection->socket,
                    smtpConnection->domain,
                    response,
                    "RSET");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideMailFromOrQuit(connection, head, response, readFdSet, writeFdSet);
/*  END   == RSET SUCCESS DECIDE TO MAIL TO OR QUIT == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_rset_unreadable_decide_to_reconnect_or_close(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == RSET UNREADABLE DECIDE TO RECONNECT OR CLOSE == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    logUnreadableResponse(smtpConnection->socket,
                          smtpConnection->domain,
                          response,
                          "RSET");
    changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    return decideReconnectOrClose(connection, head, response, readFdSet, writeFdSet);
/*  END   == RSET UNREADABLE DECIDE TO RECONNECT OR CLOSE == DO NOT CHANGE THIS COMMENT  */
}

static te_fsm_state
fsm_do_send_bytes(
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet,
    te_fsm_state initial,
    te_fsm_state maybe_next,
    te_fsm_event trans_evt)
{
/*  START == SEND BYTES == DO NOT CHANGE THIS COMMENT  */
    SMTPConnection *smtpConnection = (SMTPConnection*) connection;
    if (!smtpConnectionIsNeedToWrite(connection)) {
        FD_CLR(smtpConnection->socket, writeFdSet);
    } else {
        changeState(smtpConnection, FSM_STATE_NAME(initial), maybe_next, FSM_STATE_NAME(maybe_next));
    }
    return maybe_next;
/*  END   == SEND BYTES == DO NOT CHANGE THIS COMMENT  */
}

/**
 *  Step the FSM.  Returns the resulting state.  If the current state is
 *  FSM_ST_DONE or FSM_ST_INVALID, it resets to
 *  FSM_ST_INIT and returns FSM_ST_INIT.
 */
te_fsm_state
fsm_step(
    te_fsm_state fsm_state,
    te_fsm_event trans_evt,
    /* SMTPConnectionList */ void **head,
    /* SMTPConnection */ void *connection,
    /* String */ const void *response,
    /* fd_set */ void *readFdSet,
    /* fd_set */ void *writeFdSet )
{
    te_fsm_state nxtSt;
    fsm_callback_t * pT;

    if ((unsigned)fsm_state >= FSM_ST_INVALID) {
        return FSM_ST_INIT;
    }

#ifndef __COVERITY__
    if (trans_evt >= FSM_EV_INVALID) {
        nxtSt = FSM_ST_INVALID;
        pT    = fsm_do_invalid;
    } else
#endif /* __COVERITY__ */
    {
        const t_fsm_transition * ttbl =
            fsm_trans_table[ fsm_state ] + trans_evt;
        nxtSt = ttbl->next_state;
        pT    = ttbl->trans_proc;
    }

    if (pT != NULL)
        nxtSt = (*pT)( head, connection, response, readFdSet, writeFdSet, fsm_state, nxtSt, trans_evt );


    /* START == FINISH STEP == DO NOT CHANGE THIS COMMENT */
    /* END   == FINISH STEP == DO NOT CHANGE THIS COMMENT */

    return nxtSt;
}
/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of fsm-fsm.c */
